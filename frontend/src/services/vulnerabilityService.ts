import { supabase } from '../lib/supabase'
import type { Database } from '../lib/supabase'
import { ApiService } from './apiService'
import { ProgressTrackingService } from './progressTrackingService'

type VulnerabilityScan = Database['public']['Tables']['vulnerability_scans']['Row']
type VulnerabilityScanInsert = Database['public']['Tables']['vulnerability_scans']['Insert']

// Enhanced types for the new vulnerability scanning system
export interface ScanOptions {
  includeGasOptimization?: boolean;
  includeComplianceCheck?: boolean;
  scanType?: 'standard' | 'comprehensive' | 'security-focused';
  contractCode?: string;
}

export interface ScanResult {
  success: boolean;
  data?: any;
  scanId?: string;
  timestamp: string;
  error?: string;
  analysisType?: string;
  supportedChains?: string[];
}

export interface VulnerabilityAnalysis {
  vulnerabilities: Array<{
    name: string;
    affectedLines: string;
    description: string;
    severity: 'critical' | 'high' | 'medium' | 'low';
    fixSuggestion: string;
    cwe?: string;
  }>;
  securityScore: number;
  riskCategory: {
    label: 'low' | 'medium' | 'high' | 'critical';
    justification: string;
  };
  codeInsights: {
    gasOptimizationTips: string[];
    antiPatternNotices: string[];
    dangerousUsage: string[];
  };
  performanceMetrics?: {
    performanceScore: number;
    optimizationPotential: {
      gasReduction: string;
      suggestions: string[];
    };
  };
  chainAnalysis?: {
    chain: string;
    chainSpecificRisks: string[];
    networkInfo: any;
  };
  analysisMetadata: {
    analysisType: string;
    models?: {
      security: string;
      codeQuality: string;
    };
    timestamp: string;
  };
}

export class VulnerabilityService {
  private static instance: VulnerabilityService;
  private apiService: ApiService;
  private progressService: ProgressTrackingService;

  constructor() {
    this.apiService = ApiService.getInstance();
    this.progressService = ProgressTrackingService.getInstance();
  }

  static getInstance(): VulnerabilityService {
    if (!this.instance) {
      this.instance = new VulnerabilityService();
    }
    return this.instance;
  }

  // Enhanced vulnerability scanning with dual LLM support and progress tracking
  async scanContract(
    contractAddress: string,
    chain: string = 'ethereum',
    options: ScanOptions = {},
    progressCallback?: (step: number, message: string) => void
  ): Promise<ScanResult> {
    const operationId = this.progressService.startOperation('scan', 100, {
      contractAddress,
      chain,
      options
    });

    try {
      this.progressService.updateProgress(operationId, 10, 'Initializing vulnerability scan');
      progressCallback?.(10, 'Initializing vulnerability scan');

      console.log(`üîç Starting enhanced vulnerability scan for ${contractAddress} on ${chain}`);

      this.progressService.updateProgress(operationId, 20, 'Connecting to dual LLM analysis system');
      progressCallback?.(20, 'Connecting to dual LLM analysis system');

      this.progressService.updateProgress(operationId, 30, 'Starting security analysis (Kimi model)');
      progressCallback?.(30, 'Starting security analysis (Kimi model)');

      this.progressService.updateProgress(operationId, 50, 'Starting code quality analysis (Gemma model)');
      progressCallback?.(50, 'Starting code quality analysis (Gemma model)');

      const response = await this.apiService.post('/v1/vulnerability/scan', {
        contractAddress,
        chain,
        options
      });

      this.progressService.updateProgress(operationId, 80, 'Combining analysis results');
      progressCallback?.(80, 'Combining analysis results');

      if (response.success) {
        this.progressService.updateProgress(operationId, 100, 'Enhanced vulnerability scan completed');
        progressCallback?.(100, 'Enhanced vulnerability scan completed');

        console.log('‚úÖ Enhanced vulnerability scan completed successfully');
        console.log(`ü§ñ Analysis type: ${response.analysisType || 'dual_llm'}`);

        const result = {
          success: true,
          data: response.data,
          scanId: response.scanId,
          timestamp: response.timestamp,
          analysisType: response.analysisType,
          supportedChains: response.supportedChains,
          operationId
        };

        this.progressService.completeOperation(operationId, result);
        return result;
      } else {
        throw new Error(response.error || 'Scan failed');
      }
    } catch (error: any) {
      console.error('‚ùå Vulnerability scan failed:', error);
      this.progressService.completeOperation(operationId, undefined, error.message);

      return {
        success: false,
        error: error.message || 'Unknown error occurred',
        timestamp: new Date().toISOString(),
        operationId
      };
    }
  }

  // Scan contract code directly (without address)
  async scanContractCode(
    contractCode: string,
    chain: string = 'ethereum',
    options: ScanOptions = {}
  ): Promise<ScanResult> {
    try {
      console.log(`üîç Starting code analysis for provided contract on ${chain}`);

      const response = await this.apiService.post('/v1/vulnerability/scan', {
        contractCode,
        chain,
        options
      });

      if (response.success) {
        console.log('‚úÖ Contract code analysis completed successfully');
        return {
          success: true,
          data: response.data,
          scanId: response.scanId,
          timestamp: response.timestamp,
          analysisType: response.analysisType,
          supportedChains: response.supportedChains
        };
      } else {
        throw new Error(response.error || 'Analysis failed');
      }
    } catch (error: any) {
      console.error('‚ùå Contract code analysis failed:', error);
      return {
        success: false,
        error: error.message || 'Unknown error occurred',
        timestamp: new Date().toISOString()
      };
    }
  }

  // Get supported chains for vulnerability scanning
  async getSupportedChains(): Promise<string[]> {
    try {
      const response = await this.apiService.get('/v1/vulnerability/chains');
      return response.supportedChains || [
        'ethereum', 'polygon', 'arbitrum', 'optimism', 'base', 'bsc', 'avalanche', 'fantom'
      ];
    } catch (error) {
      console.error('Failed to fetch supported chains:', error);
      return ['ethereum', 'polygon', 'arbitrum', 'optimism', 'base', 'bsc'];
    }
  }

  // Legacy Supabase methods (kept for backward compatibility)
  static async createScan(
    contractAddress: string,
    network: string,
    userId: string
  ): Promise<VulnerabilityScan | null> {
    try {
      const { data, error } = await supabase
        .from('vulnerability_scans')
        .insert({
          user_id: userId,
          contract_address: contractAddress,
          network: network,
          status: 'pending',
        })
        .select()
        .single()

      if (error) {
        console.error('Error creating vulnerability scan:', error)
        return null
      }

      return data
    } catch (error) {
      console.error('Error creating vulnerability scan:', error)
      return null
    }
  }

  static async updateScanResults(
    scanId: string,
    results: any,
    status: 'completed' | 'failed'
  ): Promise<VulnerabilityScan | null> {
    try {
      const { data, error } = await supabase
        .from('vulnerability_scans')
        .update({
          scan_results: results,
          status: status,
        })
        .eq('id', scanId)
        .select()
        .single()

      if (error) {
        console.error('Error updating scan results:', error)
        return null
      }

      return data
    } catch (error) {
      console.error('Error updating scan results:', error)
      return null
    }
  }

  static async getUserScans(userId: string): Promise<VulnerabilityScan[]> {
    try {
      const { data, error } = await supabase
        .from('vulnerability_scans')
        .select('*')
        .eq('user_id', userId)
        .order('created_at', { ascending: false })

      if (error) {
        console.error('Error fetching vulnerability scans:', error)
        return []
      }

      return data || []
    } catch (error) {
      console.error('Error fetching vulnerability scans:', error)
      return []
    }
  }

  static async getScan(scanId: string): Promise<VulnerabilityScan | null> {
    try {
      const { data, error } = await supabase
        .from('vulnerability_scans')
        .select('*')
        .eq('id', scanId)
        .single()

      if (error) {
        console.error('Error fetching vulnerability scan:', error)
        return null
      }

      return data
    } catch (error) {
      console.error('Error fetching vulnerability scan:', error)
      return null
    }
  }
}

// Test vulnerability scan endpoint
const axios = require('axios');

const testVulnerabilityScan = async () => {
  console.log('ðŸ§ª Testing vulnerability scan endpoint...');

  const testData = {
    contractAddress: '0x1234567890123456789012345678901234567890',
    chain: 'ethereum',
    options: {
      includeGasOptimization: true,
      scanType: 'comprehensive'
    }
  };

  try {
    console.log('ðŸ“¡ Sending vulnerability scan request...');
    const response = await axios.post('http://localhost:3002/api/v1/vulnerability/scan', testData, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer test-token'
      }
    });

    console.log('ðŸ“Š Response status:', response.status);
    console.log('âœ… Vulnerability scan result:');
    console.log(JSON.stringify(response.data, null, 2));

    if (response.data.success) {
      console.log('ðŸŽ‰ Vulnerability scan completed successfully!');
      console.log('ðŸ” Vulnerabilities found:', response.data.data?.vulnerabilities?.length || 0);
      console.log('ðŸ“Š Security score:', response.data.data?.securityScore || 'N/A');
    } else {
      console.log('âŒ Vulnerability scan failed:', response.data.error);
    }

  } catch (error) {
    console.error('âŒ Test failed:', error.response?.data || error.message);
  }
};

// Test with contract code directly
const testContractCodeScan = async () => {
  console.log('\nðŸ§ª Testing contract code scan...');

  const contractCode = `
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.19;

    contract TestContract {
        mapping(address => uint256) public balances;
        address public owner;

        constructor() {
            owner = msg.sender;
        }

        function deposit() public payable {
            balances[msg.sender] += msg.value;
        }

        function withdraw(uint256 amount) public {
            require(balances[msg.sender] >= amount, "Insufficient balance");
            balances[msg.sender] -= amount;
            payable(msg.sender).transfer(amount);
        }
    }
  `;

  const testData = {
    contractCode: contractCode,
    chain: 'ethereum',
    options: {
      includeGasOptimization: true,
      scanType: 'comprehensive'
    }
  };

  try {
    console.log('ðŸ“¡ Sending contract code scan request...');
    const response = await axios.post('http://localhost:3002/api/v1/vulnerability/scan', testData, {
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer test-token'
      }
    });

    console.log('ðŸ“Š Response status:', response.status);
    console.log('âœ… Contract code scan result:');
    console.log(JSON.stringify(response.data, null, 2));

    if (response.data.success) {
      console.log('ðŸŽ‰ Contract code scan completed successfully!');
      console.log('ðŸ” Vulnerabilities found:', response.data.data?.vulnerabilities?.length || 0);
      console.log('ðŸ“Š Security score:', response.data.data?.securityScore || 'N/A');
    } else {
      console.log('âŒ Contract code scan failed:', response.data.error);
    }

  } catch (error) {
    console.error('âŒ Test failed:', error.response?.data || error.message);
  }
};

// Run both tests
const runTests = async () => {
  await testVulnerabilityScan();
  await testContractCodeScan();
};

runTests();

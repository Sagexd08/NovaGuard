const EventEmitter = require('events');
const aiAnalysisPipeline = require('./aiAnalysisPipeline');
const logger = require('../utils/logger');

/**
 * Live Vulnerability Detection Service
 * Provides real-time vulnerability detection during smart contract development
 */
class LiveVulnerabilityDetector extends EventEmitter {
  constructor() {
    super();
    this.activeDetectionSessions = new Map();
    this.vulnerabilityPatterns = this.initializeVulnerabilityPatterns();
    this.detectionRules = this.initializeDetectionRules();
    this.detectionCache = new Map();
    this.alertThresholds = this.initializeAlertThresholds();
    this.detectionMetrics = {
      totalScans: 0,
      vulnerabilitiesDetected: 0,
      falsePositives: 0,
      averageDetectionTime: 0
    };
  }

  /**
   * Initialize vulnerability patterns for quick detection
   * @returns {Array} Vulnerability patterns
   */
  initializeVulnerabilityPatterns() {
    return [
      {
        id: 'reentrancy_risk',
        name: 'Reentrancy Vulnerability',
        pattern: /\.call\s*\(\s*[^)]*\)\s*;?\s*(?!.*require|.*assert)/g,
        severity: 'high',
        category: 'reentrancy',
        description: 'Potential reentrancy vulnerability detected',
        quickFix: 'Use checks-effects-interactions pattern or ReentrancyGuard',
        confidence: 0.8
      },
      {
        id: 'unchecked_call',
        name: 'Unchecked External Call',
        pattern: /\.call\s*\(\s*[^)]*\)\s*;(?!\s*require|.*assert)/g,
        severity: 'medium',
        category: 'unchecked-calls',
        description: 'External call return value not checked',
        quickFix: 'Check the return value of external calls',
        confidence: 0.9
      },
      {
        id: 'tx_origin_auth',
        name: 'tx.origin Authorization',
        pattern: /tx\.origin\s*==|==\s*tx\.origin/g,
        severity: 'high',
        category: 'authorization',
        description: 'Using tx.origin for authorization is dangerous',
        quickFix: 'Use msg.sender instead of tx.origin',
        confidence: 0.95
      },
      {
        id: 'block_timestamp_dependency',
        name: 'Block Timestamp Dependency',
        pattern: /block\.timestamp|now/g,
        severity: 'medium',
        category: 'timestamp-dependency',
        description: 'Dependency on block.timestamp can be manipulated',
        quickFix: 'Avoid using block.timestamp for critical logic',
        confidence: 0.7
      },
      {
        id: 'integer_overflow',
        name: 'Potential Integer Overflow',
        pattern: /[+\-*/]\s*(?!.*SafeMath|.*unchecked)/g,
        severity: 'medium',
        category: 'arithmetic',
        description: 'Potential integer overflow/underflow',
        quickFix: 'Use SafeMath library or Solidity 0.8+ built-in checks',
        confidence: 0.6
      },
      {
        id: 'delegatecall_usage',
        name: 'Delegatecall Usage',
        pattern: /\.delegatecall\s*\(/g,
        severity: 'high',
        category: 'delegatecall',
        description: 'Delegatecall can be dangerous if not properly controlled',
        quickFix: 'Ensure proper access control and storage layout compatibility',
        confidence: 0.8
      },
      {
        id: 'selfdestruct_usage',
        name: 'Selfdestruct Usage',
        pattern: /selfdestruct\s*\(/g,
        severity: 'high',
        category: 'selfdestruct',
        description: 'Selfdestruct can permanently destroy contract',
        quickFix: 'Ensure proper access control for selfdestruct',
        confidence: 0.9
      },
      {
        id: 'unprotected_function',
        name: 'Unprotected Function',
        pattern: /function\s+\w+\s*\([^)]*\)\s*public\s*(?!.*onlyOwner|.*require\s*\(|.*modifier)/g,
        severity: 'medium',
        category: 'access-control',
        description: 'Public function without access control',
        quickFix: 'Add appropriate access control modifiers',
        confidence: 0.7
      },
      {
        id: 'hardcoded_address',
        name: 'Hardcoded Address',
        pattern: /0x[a-fA-F0-9]{40}/g,
        severity: 'low',
        category: 'hardcoded-values',
        description: 'Hardcoded address detected',
        quickFix: 'Consider using configurable addresses',
        confidence: 0.5
      },
      {
        id: 'missing_zero_check',
        name: 'Missing Zero Address Check',
        pattern: /=\s*\w+\s*;(?!.*require.*!=.*address\(0\))/g,
        severity: 'low',
        category: 'validation',
        description: 'Missing zero address validation',
        quickFix: 'Add require(address != address(0)) check',
        confidence: 0.6
      }
    ];
  }

  /**
   * Initialize detection rules for complex vulnerability patterns
   * @returns {Array} Detection rules
   */
  initializeDetectionRules() {
    return [
      {
        id: 'reentrancy_complex',
        name: 'Complex Reentrancy Pattern',
        validator: this.detectComplexReentrancy.bind(this),
        severity: 'high',
        category: 'reentrancy',
        description: 'Complex reentrancy pattern detected'
      },
      {
        id: 'access_control_bypass',
        name: 'Access Control Bypass',
        validator: this.detectAccessControlBypass.bind(this),
        severity: 'high',
        category: 'access-control',
        description: 'Potential access control bypass'
      },
      {
        id: 'state_variable_shadowing',
        name: 'State Variable Shadowing',
        validator: this.detectVariableShadowing.bind(this),
        severity: 'medium',
        category: 'shadowing',
        description: 'State variable shadowing detected'
      },
      {
        id: 'uninitialized_storage',
        name: 'Uninitialized Storage Pointer',
        validator: this.detectUninitializedStorage.bind(this),
        severity: 'high',
        category: 'storage',
        description: 'Uninitialized storage pointer'
      },
      {
        id: 'dos_gas_limit',
        name: 'DoS via Gas Limit',
        validator: this.detectDoSGasLimit.bind(this),
        severity: 'medium',
        category: 'dos',
        description: 'Potential DoS via gas limit'
      }
    ];
  }

  /**
   * Initialize alert thresholds
   * @returns {Object} Alert thresholds
   */
  initializeAlertThresholds() {
    return {
      high: { minConfidence: 0.7, alertImmediately: true },
      medium: { minConfidence: 0.6, alertImmediately: false },
      low: { minConfidence: 0.5, alertImmediately: false },
      info: { minConfidence: 0.4, alertImmediately: false }
    };
  }

  /**
   * Start live vulnerability detection session
   * @param {string} userId - User identifier
   * @param {Object} sessionConfig - Session configuration
   * @returns {string} Session ID
   */
  startDetectionSession(userId, sessionConfig = {}) {
    const sessionId = this.generateSessionId();
    
    const session = {
      sessionId,
      userId,
      startedAt: new Date().toISOString(),
      lastScan: null,
      config: {
        enablePatternDetection: sessionConfig.enablePatternDetection !== false,
        enableRuleBasedDetection: sessionConfig.enableRuleBasedDetection !== false,
        enableAIDetection: sessionConfig.enableAIDetection !== false,
        alertLevel: sessionConfig.alertLevel || 'medium', // low, medium, high, all
        realTimeAlerts: sessionConfig.realTimeAlerts !== false,
        ...sessionConfig
      },
      metrics: {
        scansPerformed: 0,
        vulnerabilitiesFound: 0,
        alertsSent: 0,
        lastScanTime: 0
      },
      vulnerabilityHistory: []
    };

    this.activeDetectionSessions.set(sessionId, session);

    logger.info('Live vulnerability detection session started', {
      sessionId,
      userId,
      config: session.config
    });

    this.emit('detection:session_started', { sessionId, userId, session });

    return sessionId;
  }

  /**
   * Perform live vulnerability detection
   * @param {string} sessionId - Session identifier
   * @param {Object} codeData - Code data to analyze
   * @returns {Object} Detection results
   */
  async performLiveDetection(sessionId, codeData) {
    const startTime = Date.now();
    
    try {
      const session = this.activeDetectionSessions.get(sessionId);
      if (!session) {
        throw new Error('Invalid detection session ID');
      }

      const { content, filePath, changeType = 'edit' } = codeData;

      // Check cache first
      const cacheKey = this.generateCacheKey(content);
      const cached = this.detectionCache.get(cacheKey);
      
      if (cached && Date.now() - cached.timestamp < 10000) { // 10 second cache
        return cached.result;
      }

      const detection = {
        sessionId,
        filePath,
        timestamp: new Date().toISOString(),
        vulnerabilities: [],
        alerts: [],
        summary: {
          totalVulnerabilities: 0,
          highSeverity: 0,
          mediumSeverity: 0,
          lowSeverity: 0,
          confidence: 0
        },
        metadata: {
          changeType,
          detectionTime: 0,
          methodsUsed: []
        }
      };

      // Pattern-based detection (fast)
      if (session.config.enablePatternDetection) {
        const patternResults = await this.performPatternDetection(content);
        detection.vulnerabilities.push(...patternResults);
        detection.metadata.methodsUsed.push('pattern');
      }

      // Rule-based detection (medium speed)
      if (session.config.enableRuleBasedDetection) {
        const ruleResults = await this.performRuleBasedDetection(content);
        detection.vulnerabilities.push(...ruleResults);
        detection.metadata.methodsUsed.push('rule-based');
      }

      // AI-based detection (slower, for critical changes)
      if (session.config.enableAIDetection && this.shouldPerformAIDetection(changeType, detection.vulnerabilities)) {
        const aiResults = await this.performAIDetection(content);
        detection.vulnerabilities.push(...aiResults);
        detection.metadata.methodsUsed.push('ai');
      }

      // Process and filter results
      detection.vulnerabilities = this.processDetectionResults(detection.vulnerabilities, session);
      
      // Generate summary
      this.generateDetectionSummary(detection);

      // Generate alerts
      detection.alerts = this.generateAlerts(detection.vulnerabilities, session);

      // Update session metrics
      const detectionTime = Date.now() - startTime;
      detection.metadata.detectionTime = detectionTime;
      session.metrics.scansPerformed++;
      session.metrics.vulnerabilitiesFound += detection.vulnerabilities.length;
      session.metrics.alertsSent += detection.alerts.length;
      session.metrics.lastScanTime = detectionTime;
      session.lastScan = new Date().toISOString();

      // Store in history
      session.vulnerabilityHistory.push({
        timestamp: detection.timestamp,
        vulnerabilityCount: detection.vulnerabilities.length,
        highSeverityCount: detection.summary.highSeverity,
        filePath
      });

      // Keep only recent history
      if (session.vulnerabilityHistory.length > 100) {
        session.vulnerabilityHistory = session.vulnerabilityHistory.slice(-100);
      }

      // Cache result
      this.detectionCache.set(cacheKey, {
        result: detection,
        timestamp: Date.now()
      });

      // Update global metrics
      this.updateGlobalMetrics(detectionTime, detection.vulnerabilities.length);

      // Emit events
      this.emit('detection:completed', { sessionId, detection });

      if (detection.alerts.length > 0) {
        this.emit('detection:alerts', { sessionId, alerts: detection.alerts });
      }

      return detection;

    } catch (error) {
      logger.error('Live vulnerability detection failed', { 
        sessionId,
        error: error.message 
      });
      throw error;
    }
  }

  /**
   * Perform pattern-based detection
   * @param {string} content - Contract code
   * @returns {Array} Detected vulnerabilities
   */
  async performPatternDetection(content) {
    const vulnerabilities = [];

    this.vulnerabilityPatterns.forEach(pattern => {
      const matches = content.matchAll(pattern.pattern);
      
      for (const match of matches) {
        const lineNumber = this.getLineNumber(content, match.index);
        const columnNumber = this.getColumnNumber(content, match.index);
        
        vulnerabilities.push({
          id: pattern.id,
          name: pattern.name,
          severity: pattern.severity,
          category: pattern.category,
          description: pattern.description,
          line: lineNumber,
          column: columnNumber,
          confidence: pattern.confidence,
          quickFix: pattern.quickFix,
          detectionMethod: 'pattern',
          codeSnippet: this.extractCodeSnippet(content, lineNumber),
          timestamp: new Date().toISOString()
        });
      }
    });

    return vulnerabilities;
  }

  /**
   * Perform rule-based detection
   * @param {string} content - Contract code
   * @returns {Array} Detected vulnerabilities
   */
  async performRuleBasedDetection(content) {
    const vulnerabilities = [];

    for (const rule of this.detectionRules) {
      try {
        const results = await rule.validator(content);
        results.forEach(result => {
          vulnerabilities.push({
            id: rule.id,
            name: rule.name,
            severity: rule.severity,
            category: rule.category,
            description: rule.description,
            ...result,
            detectionMethod: 'rule-based',
            timestamp: new Date().toISOString()
          });
        });
      } catch (error) {
        logger.error('Rule-based detection failed', { 
          ruleId: rule.id,
          error: error.message 
        });
      }
    }

    return vulnerabilities;
  }

  /**
   * Perform AI-based detection
   * @param {string} content - Contract code
   * @returns {Array} Detected vulnerabilities
   */
  async performAIDetection(content) {
    try {
      const analysis = await aiAnalysisPipeline.analyzeContract({
        contractCode: content,
        agents: ['security'],
        analysisMode: 'quick'
      });

      return (analysis.vulnerabilities || []).map(vuln => ({
        ...vuln,
        detectionMethod: 'ai',
        timestamp: new Date().toISOString()
      }));

    } catch (error) {
      logger.error('AI-based detection failed', { error: error.message });
      return [];
    }
  }

  /**
   * Complex reentrancy detection
   * @param {string} content - Contract code
   * @returns {Array} Detection results
   */
  async detectComplexReentrancy(content) {
    const results = [];
    const lines = content.split('\n');
    
    // Look for state changes after external calls
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes('.call(') || line.includes('.send(') || line.includes('.transfer(')) {
        // Check subsequent lines for state changes
        for (let j = i + 1; j < Math.min(i + 5, lines.length); j++) {
          if (lines[j].includes('=') && !lines[j].includes('require') && !lines[j].includes('assert')) {
            results.push({
              line: i + 1,
              column: 0,
              confidence: 0.8,
              description: 'State change after external call - potential reentrancy',
              codeSnippet: lines.slice(i, j + 1).join('\n')
            });
            break;
          }
        }
      }
    }

    return results;
  }

  /**
   * Access control bypass detection
   * @param {string} content - Contract code
   * @returns {Array} Detection results
   */
  async detectAccessControlBypass(content) {
    const results = [];
    
    // Look for functions that modify state without proper access control
    const functionPattern = /function\s+(\w+)\s*\([^)]*\)\s*(public|external)/g;
    const matches = content.matchAll(functionPattern);
    
    for (const match of matches) {
      const functionName = match[1];
      const lineNumber = this.getLineNumber(content, match.index);
      
      // Check if function has access control
      const functionBody = this.extractFunctionBody(content, match.index);
      const hasAccessControl = /require\s*\(.*msg\.sender|onlyOwner|onlyAdmin/.test(functionBody);
      const modifiesState = /=\s*[^=]|\.push\(|\.pop\(|delete\s/.test(functionBody);
      
      if (modifiesState && !hasAccessControl && !functionName.startsWith('_')) {
        results.push({
          line: lineNumber,
          column: 0,
          confidence: 0.7,
          description: `Function '${functionName}' modifies state without access control`,
          codeSnippet: this.extractCodeSnippet(content, lineNumber)
        });
      }
    }

    return results;
  }

  /**
   * Variable shadowing detection
   * @param {string} content - Contract code
   * @returns {Array} Detection results
   */
  async detectVariableShadowing(content) {
    const results = [];
    
    // Extract state variables and function parameters
    const stateVars = this.extractStateVariables(content);
    const functionParams = this.extractFunctionParameters(content);
    
    functionParams.forEach(param => {
      const shadowedVar = stateVars.find(stateVar => stateVar.name === param.name);
      if (shadowedVar) {
        results.push({
          line: param.line,
          column: param.column,
          confidence: 0.9,
          description: `Parameter '${param.name}' shadows state variable`,
          codeSnippet: this.extractCodeSnippet(content, param.line)
        });
      }
    });

    return results;
  }

  /**
   * Uninitialized storage pointer detection
   * @param {string} content - Contract code
   * @returns {Array} Detection results
   */
  async detectUninitializedStorage(content) {
    const results = [];
    
    // Look for struct declarations without initialization
    const structPattern = /(\w+)\s+storage\s+(\w+);/g;
    const matches = content.matchAll(structPattern);
    
    for (const match of matches) {
      const lineNumber = this.getLineNumber(content, match.index);
      results.push({
        line: lineNumber,
        column: 0,
        confidence: 0.8,
        description: 'Uninitialized storage pointer detected',
        codeSnippet: this.extractCodeSnippet(content, lineNumber)
      });
    }

    return results;
  }

  /**
   * DoS via gas limit detection
   * @param {string} content - Contract code
   * @returns {Array} Detection results
   */
  async detectDoSGasLimit(content) {
    const results = [];
    
    // Look for unbounded loops
    const loopPattern = /for\s*\([^)]*;\s*\w+\s*<\s*\w+\.length/g;
    const matches = content.matchAll(loopPattern);
    
    for (const match of matches) {
      const lineNumber = this.getLineNumber(content, match.index);
      results.push({
        line: lineNumber,
        column: 0,
        confidence: 0.6,
        description: 'Unbounded loop may cause DoS via gas limit',
        codeSnippet: this.extractCodeSnippet(content, lineNumber)
      });
    }

    return results;
  }

  // Helper methods
  shouldPerformAIDetection(changeType, existingVulns) {
    return changeType === 'save' || existingVulns.some(v => v.severity === 'high');
  }

  processDetectionResults(vulnerabilities, session) {
    // Remove duplicates and filter by confidence threshold
    const threshold = this.alertThresholds[session.config.alertLevel];
    
    return vulnerabilities
      .filter(vuln => vuln.confidence >= threshold.minConfidence)
      .filter((vuln, index, arr) => 
        arr.findIndex(v => v.id === vuln.id && v.line === vuln.line) === index
      );
  }

  generateDetectionSummary(detection) {
    detection.summary.totalVulnerabilities = detection.vulnerabilities.length;
    detection.summary.highSeverity = detection.vulnerabilities.filter(v => v.severity === 'high').length;
    detection.summary.mediumSeverity = detection.vulnerabilities.filter(v => v.severity === 'medium').length;
    detection.summary.lowSeverity = detection.vulnerabilities.filter(v => v.severity === 'low').length;
    
    if (detection.vulnerabilities.length > 0) {
      detection.summary.confidence = detection.vulnerabilities.reduce((sum, v) => sum + v.confidence, 0) / detection.vulnerabilities.length;
    }
  }

  generateAlerts(vulnerabilities, session) {
    const alerts = [];
    const threshold = this.alertThresholds[session.config.alertLevel];
    
    vulnerabilities.forEach(vuln => {
      const shouldAlert = threshold.alertImmediately || vuln.severity === 'high';
      
      if (shouldAlert && session.config.realTimeAlerts) {
        alerts.push({
          type: 'vulnerability',
          severity: vuln.severity,
          message: `${vuln.name}: ${vuln.description}`,
          line: vuln.line,
          quickFix: vuln.quickFix,
          timestamp: new Date().toISOString()
        });
      }
    });

    return alerts;
  }

  updateGlobalMetrics(detectionTime, vulnerabilityCount) {
    this.detectionMetrics.totalScans++;
    this.detectionMetrics.vulnerabilitiesDetected += vulnerabilityCount;
    
    const currentAvg = this.detectionMetrics.averageDetectionTime;
    const count = this.detectionMetrics.totalScans;
    this.detectionMetrics.averageDetectionTime = 
      (currentAvg * (count - 1) + detectionTime) / count;
  }

  // Utility methods
  getLineNumber(content, index) {
    return content.substring(0, index).split('\n').length;
  }

  getColumnNumber(content, index) {
    const lines = content.substring(0, index).split('\n');
    return lines[lines.length - 1].length + 1;
  }

  extractCodeSnippet(content, lineNumber, radius = 2) {
    const lines = content.split('\n');
    const start = Math.max(0, lineNumber - radius - 1);
    const end = Math.min(lines.length, lineNumber + radius);
    return lines.slice(start, end).join('\n');
  }

  extractFunctionBody(content, functionStartIndex) {
    // Simplified function body extraction
    const fromFunction = content.substring(functionStartIndex);
    const openBrace = fromFunction.indexOf('{');
    if (openBrace === -1) return '';
    
    let braceCount = 1;
    let i = openBrace + 1;
    
    while (i < fromFunction.length && braceCount > 0) {
      if (fromFunction[i] === '{') braceCount++;
      else if (fromFunction[i] === '}') braceCount--;
      i++;
    }
    
    return fromFunction.substring(openBrace, i);
  }

  extractStateVariables(content) {
    // Simplified state variable extraction
    const variables = [];
    const varPattern = /(\w+)\s+(?:public\s+|private\s+|internal\s+)?(\w+)\s*;/g;
    let match;
    
    while ((match = varPattern.exec(content)) !== null) {
      variables.push({
        type: match[1],
        name: match[2],
        line: this.getLineNumber(content, match.index)
      });
    }
    
    return variables;
  }

  extractFunctionParameters(content) {
    // Simplified function parameter extraction
    const parameters = [];
    const funcPattern = /function\s+\w+\s*\(([^)]*)\)/g;
    let match;
    
    while ((match = funcPattern.exec(content)) !== null) {
      const params = match[1].split(',');
      params.forEach(param => {
        const paramMatch = param.trim().match(/(\w+)\s+(\w+)/);
        if (paramMatch) {
          parameters.push({
            type: paramMatch[1],
            name: paramMatch[2],
            line: this.getLineNumber(content, match.index),
            column: this.getColumnNumber(content, match.index)
          });
        }
      });
    }
    
    return parameters;
  }

  generateCacheKey(content) {
    return require('crypto').createHash('md5').update(content).digest('hex');
  }

  generateSessionId() {
    return `vuln_detect_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  /**
   * End detection session
   * @param {string} sessionId - Session identifier
   */
  endDetectionSession(sessionId) {
    const session = this.activeDetectionSessions.get(sessionId);
    if (session) {
      session.endedAt = new Date().toISOString();
      this.activeDetectionSessions.delete(sessionId);
      
      logger.info('Live vulnerability detection session ended', {
        sessionId,
        duration: Date.now() - new Date(session.startedAt).getTime(),
        metrics: session.metrics
      });

      this.emit('detection:session_ended', { sessionId, session });
    }
  }

  /**
   * Get service status
   * @returns {Object} Service status
   */
  getStatus() {
    return {
      activeSessions: this.activeDetectionSessions.size,
      cacheSize: this.detectionCache.size,
      globalMetrics: this.detectionMetrics,
      patternsLoaded: this.vulnerabilityPatterns.length,
      rulesLoaded: this.detectionRules.length
    };
  }
}

module.exports = new LiveVulnerabilityDetector();
